use postgres_pool::{Connection, Pool};
use std::sync::Arc;

/// Protocol-agnostic Postgres handlers for any connection pool
#[derive(Clone)]
pub struct Postgres<P> {
    pool: Arc<P>,
}

impl<P> Postgres<P>
where
    P: Pool,
    P::Error: From<<P::Connection as Connection>::Error>,
{
    /// Create a new Postgres service from a reference-counted Pool
    pub fn new(pool: Arc<P>) -> Self {
        Self { pool }
    }

    /// Query a Postgres database
    #[tracing::instrument(skip(self))]
    pub async fn query(
        &self,
        key: P::Key,
        statement: &str,
        parameters: &[<P::Connection as Connection>::Parameter],
    ) -> Result<<P::Connection as Connection>::RowStream, P::Error> {
        tracing::info!("Querying postgres");

        let rows = self
            .pool
            .get_connection(key)
            .await?
            .query(statement, &parameters)
            .await?;

        Ok(rows)
    }
}

#[cfg(feature = "http-service")]
pub(crate) mod http_service {
    use super::Postgres;
    use http::{
        header::CONTENT_TYPE, Extensions, HeaderMap, Method, Request, Response, StatusCode,
    };
    use hyper::{body::Buf, Body};
    use postgres_pool::{Connection, Pool};
    use serde::{de::DeserializeOwned, Deserialize};
    use std::{
        convert::TryFrom,
        future::Future,
        pin::Pin,
        task::{Context, Poll},
    };
    use thiserror::Error;
    use tower::Service;

    /// Supported request components for this service
    const SUPPORTED_CONTENT_TYPES: &'static [&'static str] = &["application/json"];
    const SUPPORTED_PATHS: &'static [(&'static str, &'static Method)] =
        &[("/query", &Method::POST)];

    /// picker function for top-level routing through tower::Steer
    pub(crate) fn pick<T>(request: &Request<T>) -> bool {
        let is_supported_content_type = match request
            .headers()
            .get(CONTENT_TYPE)
            .and_then(|header| header.to_str().ok())
        {
            Some(header) => SUPPORTED_CONTENT_TYPES.contains(&header),
            None => return false,
        };

        is_supported_content_type
            && SUPPORTED_PATHS.contains(&(request.uri().path(), request.method()))
    }

    /// A generic version of the QueryRequest generated by protoc
    #[derive(Deserialize)]
    struct QueryRequest<P>
    where
        P: Pool,
        <P::Connection as Connection>::Parameter: DeserializeOwned,
    {
        statement: String,
        values: Vec<<P::Connection as Connection>::Parameter>,
    }

    /// HTTP service errors that can be converted into responses
    #[derive(Debug, Error)]
    enum Error<P>
    where
        P: Into<StatusCode> + std::error::Error,
    {
        #[error("Missing required Content-Type header")]
        MissingContentType,
        #[error("Unsupported Content-Type {0}")]
        UnsupportedContentType(String),
        #[error("Error parsing the request body: {0}")]
        InvalidBody(#[from] hyper::Error),
        #[error("Error reading Content-Type header: {0}")]
        InvalidContentType(#[from] hyper::header::ToStrError),
        #[error("Error parsing JSON request payload: {0}")]
        InvalidJson(#[from] serde_json::Error),
        #[error(transparent)]
        Pool(P),
    }

    impl<P> From<Error<P>> for StatusCode
    where
        P: Into<StatusCode> + std::error::Error,
    {
        fn from(error: Error<P>) -> Self {
            match error {
                Error::Pool(error) => error.into(),
                _ => Self::BAD_REQUEST,
            }
        }
    }

    impl<P> TryFrom<Error<P>> for Response<Body>
    where
        P: Into<StatusCode> + std::error::Error,
    {
        type Error = http::Error;

        fn try_from(error: Error<P>) -> Result<Self, Self::Error> {
            let body = Body::from(error.to_string());

            Response::builder()
                .status(StatusCode::from(error))
                .body(body)
        }
    }

    /// HTTP service implementation for Postgres handlers
    impl<P> Service<Request<Body>> for Postgres<P>
    where
        Self: Clone,
        P: Pool + 'static,
        P::Error: From<<P::Connection as Connection>::Error> + Into<StatusCode> + Send,
        P::Key: From<Extensions> + Send,
        <P::Connection as Connection>::Parameter: for<'de> Deserialize<'de>,
        <P::Connection as Connection>::RowStream: Into<Body>,
    {
        type Response = Response<Body>;
        type Error = http::Error;
        type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send>>;

        fn poll_ready(&mut self, _context: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }

        fn call(&mut self, request: Request<Body>) -> Self::Future {
            // split the request into useful parts
            let (parts, body) = request.into_parts();

            // guard against incorrect methods
            if parts.method != Method::POST {
                return Box::pin(async {
                    Response::builder()
                        .status(StatusCode::METHOD_NOT_ALLOWED)
                        .body(Body::empty())
                });
            }

            // guard against incorrect paths
            if !parts.uri.path().ends_with("/query") {
                return Box::pin(async {
                    Response::builder()
                        .status(StatusCode::NOT_FOUND)
                        .body(Body::empty())
                });
            }

            // prepare the shared query components
            let headers = parts.headers;
            let key: P::Key = parts.extensions.into();
            let postgres = self.clone();

            Box::pin(async move {
                query(headers, body, key, postgres)
                    .await
                    .map(Response::new)
                    .or_else(Response::try_from)
            })
        }
    }

    /// parse the statement and parameters from the body based on the Content-Type header
    async fn query<P>(
        headers: HeaderMap,
        body: Body,
        key: P::Key,
        postgres: Postgres<P>,
    ) -> Result<Body, Error<P::Error>>
    where
        P: Pool,
        P::Error: Into<StatusCode>,
        P::Error: From<<P::Connection as Connection>::Error>,
        <P::Connection as Connection>::Parameter: DeserializeOwned,
        <P::Connection as Connection>::RowStream: Into<Body>,
    {
        let QueryRequest { statement, values } = match headers
            .get(CONTENT_TYPE)
            .ok_or(Error::MissingContentType)?
            .to_str()?
        {
            "application/json" => {
                let reader = hyper::body::aggregate(body).await?.reader();
                serde_json::from_reader::<_, QueryRequest<P>>(reader)?
            }
            unsupported_type => {
                return Err(Error::UnsupportedContentType(unsupported_type.to_string()))
            }
        };

        let rows = postgres
            .query(key, &statement, &values)
            .await
            .map_err(Error::Pool)?;

        Ok(rows.into())
    }
}
